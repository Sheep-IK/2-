1.1 최대 숫자 찾기
가장 큰 숫자 찾기
>> 중간카드 집고 비교
카드를 한 장 씩 차례대로 읽어가며 찾는 방법 
순차탐색


1.3 동전 거스름돈
물건을 사고 거스름돈을 동전으로 받아야 한다면?
대부분 가장 적은 수의 동전을 원한다
그리디 알고리즘

1.4 한붓그리기
궤적을 그리는동안 연필이 종이에서 떨어져서는 안된다
그래프가 작으면 연필로 '시행착오' 를 통해
현재 점으로 돌아오는 사이클이 있으면 진행
단 외길이면 즉, 인접한 점이 하나밖에 없으면 사이클 체크 없이 인접한 점으로 진행
홀수점이 두개거나 모두 짝수점인 경우

1.5 미로찾기
편한 방법으로 만들고 푼다
오른손 법칙

1.6 동전문제
반을 가른 뒤 차이가 있는것에서 또 반을 나누고 반을 나누고 반복
분할 정복


1.7 독이든 술단지
2진수 해를 이용하여 푼다


2.2 최초의 알고리즘
유클리드의 최대공약수 알고리즘
가장 오래된 알고리즘

2개의 자연수의 최대공약수는 큰 수에서 작은 수를 뺀 수와 
작은 수와의 최대공약수와 같다

2.3 알고리즘 표현방법
알고리즘의 형태는 단계별 절차 (마치 요리책의 요리를 만드는 절차)
일반적으로 알고리즘은 프로그래밍 언어와 유사한 '의사코드로 표현'

플로우 차트 (flow chart)

2.4 알고리즘의 분류
문제의 해결 방식에 따른 분류

2.5 알고리즘의 효율성 표현
알고리즘의 '수행 시간' 또는 알고리즘이 수행하는 동안 
'사용되는 메모리 크기'로 나타낼 수 있다
시간복잡도(별로 안중요) , 공간복잡도
일반적으로 비교할때 시간복잡도가 많이 사용됨

알고리즘의 복잡도 표현방법
최악 경우 분석 : 어떤 입력이 주어지더라도 수행시간이
얼마 이상은 넘지 않는다 라는 '상한'의 의미
보통 최악 경우를 표현 but(Qsort, 삽입sort 는 예외)

평균 경우 분석

최선 경우 분석

2.6 복잡도의 점근적 표기
시간 복잡도는 입력 크기에 대한 함수로 표기

big o 표기 : 점근적 상한

o-표기법 찾는 간단한 방법
세타를 찾는법 : 다항식에서 최고 차수 항만을 취한 뒤, 
그 항의 계수를 제거하여 g(n)을 정한다

사전적  O 표기를 찾는것인가 세타를 찾는것인가 주의

함수의 증가율 비교
로그함수, 지수함수 등 차이

2.7 효율적 알고리즘의 필요성
알고리즘은 대부분 의사코드로 표현
시간복잡도 주로 사용
시간 복잡도 : 알고리즘이 수행하는 기본적인 연산 횟수를 표현

점근적 표기 : n이 무한대로 커질 때의 복잡도 표현
big-o : 점근적 표기

정렬 알고리즘

6.1 버블 정렬

6.2 선택 정렬
입력 배열 전체에서 최솟값을 선택
특징 : 항상 일정한 시간 복잡도,
         입력에 민감하지 않음

6.3 삽입 정렬
배열을 정렬된 부분과 정렬 안된부분으로 나누고 
정렬 안된 원소를 정렬된 부분의 적절한 위치에 삽입하여 정렬

최악 경우 n^2
최선 경우 : 입력이 이미 정렬되어 있으면o(n)

6.4 쉘 정렬
Motivation
간격(gap) 를 이용

시간 복잡도 : 아직 안정해짐
특성 : 입력 크기가 매우 크지 않은 경우에 좋은 성능,
                임베디드 시스템에서 주로 사용 (간격에 따른 그룹별 정렬방식이 유용해서)

6.5 힙 정렬

중간중간 과정 보여주고 다음은 어떤 과정이 일어나느냐? 라고
문제를 낼 예정이랍니다 (~랑 ~ 비교하여 얼로 이동한다 이런)
DownHeap(이거 나오나봄)<<<<<<<<<<<<<<<<<<<<<<<<<<
시간 복잡도 : 힙 만드는데 O(n)
최선 최악 평균 동일 : O(nlogn)

비교정렬은 어떤 값이 와도 가능
비교 정렬 문제의 하한은 _n_(nlogn) 


기수 정렬 : O(k(n+r))

6.6 정렬 문제의 하한
비교 정렬

분할 정복 알고리즘
주어진 문제의 입력을 분할하여 문제를 해결하는 방식의 알고리즘

분할한 입력에 동일한 알고리즘 적용하여 계산
이들의 해를 취합하여 원래 문제의 해를 얻음

3.1 합병 정렬
단점 : 입력을 위한 메모리 공간 외에 추가로 크기가 같은 공간이 별도 필요
공간 복잡도 O(n)

3.2 퀵 정렬
퀵 정렬은 분할 정복 알고리즘으로 분류
정복 후 분할
피봇 : 피봇은 왼편 오른편 포함 x
피봇 선정 방법 : Median-of-Median
성능 향상 방법 : 삽입 정렬을 동시에 사용

3.3 선택 문제
Small group에 k번째 작은 숫자가 속한 경우
k번째 작은 숫자를 찾는다
Large group에서 k번째 작은 숫자가 있는경우
k-(small group 개수) - 1(피봇) 번째 숫자를 찾는다

3.4 최근접 점의 쌍 찾기


피보나치 수 계산을 위한 o(n) 
fibNumber(n)


합병정렬 O(n)
퀵 정렬 O(nlog2n)
최근접 점 O(nlogn)6
버블 정렬 , 선택정렬 , 삽입정렬 O(n^2)
힙 정렬 O(nlogn)